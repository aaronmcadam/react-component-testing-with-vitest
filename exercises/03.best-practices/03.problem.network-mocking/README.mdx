# Network mocking

We've got quite far testing the `<DiscountCodeForm />` component but there's just one problem. The component has been a bit naive. It simply took the entered discount code and put it in internal state. That's not how things work in real life. In practice, it would likely send that code to some server to validate and apply. It would make a _network call_.

In fact, I went and refactored the discount code component to do just that! Now, submitting the form dispatches a `POST https://api.example.com/discount/code` request with the provided code. Only once the server sends back the confirmation will the component display the applied discount in the UI.

This poses a new challenge: that `POST` request _will actually happen during the test run_. That may be acceptable in end-to-end testing but never on the integration level.

<callout-success>Always mock HTTP requests in integration tests.</callout-success>

Leaving that request to fire during tests means that we are allowing the server's operability and behavior to influence the outcome of the test. This is a no-go as it violates :scroll: [The Golden Rule of Assertions](https://www.epicweb.dev/the-golden-rule-of-assertions):

<callout-info>_A test must fail if, and only if, the intention behind the system is not met._</callout-info>

In other words, our component can be functioning perfectly but the test may still fail if the server is down or having trouble processing the request. The responsibility of the integration test is to assert the client-side code we've written, and never the server-side one.

You have to draw the line. You have to draw a :scroll: [Test boundary](https://www.epicweb.dev/what-is-a-test-boundary).

When it comes to the network, you employ API mocking tools to establish that boundary and help your tests focus on the right thing, turning the dynamic and unpredictable thing such as network to fixed and given.

In this exercise, we would have toto intercept and mock the `POST https://api.example.com/discount/code` that our component makes during tests. We will use the library called [Mock Service Worker](https://mswjs.io/) (MSW) to do that.

## Using MSW with Vitest Browser Mode

Integrating MSW with Vitest Browser Mode is a little different from the usual browser integration so let's go throuigh it together. Follow the instructions below.

### Installation and setup

üê® Start by installing the `msw` package as a dependency:

```sh nonumber
npm install -D msw
```

üê® Generate the Service Worker script that MSW will use to intercept requests in the browser by running this command:

```sh nonumber
npx msw init ./public
```

üê® Create a new folder in `src` called `mocks`. In `src/mocks`, create a new file called `handlers.ts`. For now, let it export a single empty array called `handlers`:

```ts filename=src/mocks/handlers.ts
export const handlers = []
```

üê® Next, create a browser integration file at <InlineFile file="./src/mocks/browser.ts">`src/mocks/browser.ts`</InlineFile>. Feel free to paste the following content there:

```ts filename=src/mocks/browser.ts
import { setupWorker } from 'msw/browser'
import { handlers } from './handlers.js'

export const worker = setupWorker(...handlers)

export async function startWorker() {
	await worker.start({
		quiet: true,
		onUnhandledRequest(request, print) {
			if (/(\.(css|tsx?|woff2?))/.test(request.url)) {
				return
			}

			print.error()
		},
	})
}
```

Let's briefly go over what's happening here:

- The `setupWorker()` function prepares a Service Worker instance configured with the given request `handlers`. Note that it _doesn't start it_ just yet!
- The `startWorker()` function abstracts starting the worker so we can potentially reuse it in multiple places.
  - `quiet: true` disables MSW logging to keep our consoles clean.
  - `onUnhandledRequest` decides how to handle requests that you don't have mocks for. In this case, we are ignoring any asset requests while reacting to any other unhandled requests with an error.

After this step, you would normally introduce the `enableMocking()` function and wrap it around your application's initialization. With Vitest Browser Mode, the root of your app (`main.tsx`) doesn't run in tests so you need to start MSW differently.

For that, you will use a _custom test context_.

### Vitest Browser Mode integration

üê® Create a new file called <InlineFile file="./test-extend.ts">`test-extend.ts`</InlineFile>.

Since it's a new TypeScript module, you need to tell TypeScript how to handle it. Right now, no configurations include this module so writing any code there will error.

üê® In <InlineFile file="tsconfig.test.browser.json">`tsconfig.test.browser.json`</InlineFile>, add `"test-extend.ts"` to the `include` array:

```json filename=tsconfig.test.browser.json remove=3 add=4
{
	"extends": "./tsconfig.base.json",
	"include": ["**/*.browser.test.ts*"],
	"include": ["**/*.browser.test.ts*", "test-extend.ts"],
	"compilerOptions": {
		"target": "esnext",
		"module": "preserve",
		"types": ["vitest/globals", "@vitest/browser/providers/playwright"]
	}
}
```

> We are adding it to the configuration for browser tests because the code in `test-extend.ts` will run in the browser.

üê® In `test-extend.ts`, import `test as testBase` from `vitest`:

```ts filename=test-extend.ts add=1
import { test as testBase } from 'vitest'
```

üê® Create a new variable called `test` (this will be your custom test context) and assing it to the `testBase.extend()` function call:

```ts filename=test-extend.ts add=3
import { test as testBase } from 'vitest'

export const test = testBase.extend()
```

> :owl: Calling `.extend()` allows you to put _custom properties_ you can then access on the `test()` function.

üê® Provide an object as an argument to the `testBase.extend()` call and declare a new property on that object called `worker`:

```ts filename=test-extend.ts add=4
import { test as testBase } from 'vitest'

export const test = testBase.extend({
	worker: [fixture, options],
})
```

Right now, the `worker` property has an array of two elements: `fixture` and `options`. You will use the `fixture` to describe what the worker should do when it's accessed. You will use the `options` to provide additional options associated with this fixture.

üê® Provide the following fixture for the `worker`:

```ts filename=test-extend.ts add=2,6-10
import { test as testBase } from 'vitest'
import { startWorker, worker } from './src/mocks/browser.js'

export const test = testBase.extend({
	worker: [
		async ({}, use) => {
			await startWorker()
			await use(worker)
			worker.stop()
		},
		options,
	],
})
```

In this fixture, you are telling Vitest to start the worker (`await startWorker()` from `src/mocks/browser.js` you've prepared earlier), then expose it to the test (`await use(worker)`), and finally call `worker.stop()` after the test is done.

There's just a slight issue with this. By default, fixtures in Vitest are _lazy_, which means they will not be initialized unless they are referenced in a test. Here's what that means:

```ts filename=some.test.ts highlight=3,7
// MSW will not start here because this test does not
// reference the `worker` fixture you've created.
test('first scenario', () => {})

// This test does reference the `worker` fixture,
// which will correctly start MSW for this test.
test('second scenario', ({ worker }) => {})
```

You want MSW up and running _in every test_ so you can take advantage of its request handler layering even if you don't reference the `worker` explicitly.

üê® To do that, configure the `worker` fixture to have the `auto: true` option:

```ts filename=test-extend.ts add=11
import { test as testBase } from 'vitest'
import { startWorker, worker } from './src/mocks/browser.js'

export const test = testBase.extend({
	worker: [
		async ({}, use) => {
			await startWorker()
			await use(worker)
			worker.stop()
		},
		{ auto: true },
	],
})
```

> :owl: Passing `auto: true` to a fixture will make Vitest initialize it _automatically_, even if it's not explicitly referenced in the test.

With the setup finally done, let's move on to describing the network.

### Describing the network

üê® Head back to `src/mocks/handlers.ts`. In this file, you will describe the network behaviors you want here. Import `http` and `HttpResponse` from `msw`:

```ts filename=src/mocks/handlers.ts add=1
import { http, HttpResponse } from 'msw'
```

Now is the turn to _describe the network_ you want. In MSW, you do that using functions called [Request handlers](https://mswjs.io/docs/concepts/request-handler) that are responsible for two things: intercepting requests and deciding how to handle them.

üê® In `src/mocks/handlers.ts`, export an array called `handlers` and declare your first request handler for the `POST https://api.example.com/discount/code` request in it:

```ts filename=src/mocks/handlers.ts add=3-5
import { http, HttpResponse } from 'msw'

export const handlers = [
	http.post('https://api.example.com/discount/code', () => {}),
]
```

This request handler will intercept any matching requests and execute the callback function you've provided as the second argument. That function‚Äîalso called a _response resolver_‚Äîdoesn't do anything thought! Let's fix that.

Our component expects a response from the server to have the following shape:

```ts
{
	code: string
	amount: number
}
```

- `code` is the discount code sent by the client;
- `amount` is the discount amount associated with the received discount code.

Since the `code` data comes from the client, let's read the intercepted request's body to retrieve the sent discount code.

üê® In the response resolver function, access the `request` property on the argument object to the response resolver and read the reqest's body ...

```ts filename=src/mocks/handlers.ts add=7-8
import { http, HttpResponse } from 'msw'

export const handlers = [
	http.post(
		'https://api.example.com/discount/code',
		// `request` is the Fetch API representation of the intercepted request.
		async ({ request }) => {
			const code = await request.text()
		},
	),
]
```

> :owl: MSW uses the Fetch API to handle requests and responses, which means you can read the intercepted request's body differently as well (e.g. `await request.json()` or `await request.formData()`). Read it appropriately to the nature of data sent from the client.

üê® Now, respond with a mocked response to this request by returning `HttpResponse.json()` with the response body you want from the response resolver:

```ts filename=src/mocks/handlers.ts add=10-13
import { http, HttpResponse } from 'msw'

export const handlers = [
	http.post(
		'https://api.example.com/discount/code',
		// `request` is the Fetch API representation of the intercepted request.
		async ({ request }) => {
			const code = await request.text()

			return HttpResponse.json({
				code,
				amount: 20,
			})
		},
	),
]
```

> :owl: [`HttpResponse`](https://mswjs.io/docs/api/http-response) is a 1-1 compatible abstraction on top of the Fetch API `Response` that supports shorthand response declaration methods otherwise unavailable in the specification, like `HttpResponse.blob()` or `HttpResponse.formData()`. You use it purely for convenience and can always substitute it with a plain `Response` instance.

With MSW in place, it will act as the actual network for our automated test.

## Your task

What, you thought you were done? Not yet. You've just got to the good part, after all!

üë®‚Äçüíº Now that you are in charge of the network, your task is to complete the test cases for different network-related scenarios in <InlineFile filename="./src/discount-code-form.browser.test.tsx">`discount-code-form.browser.test.tsx`</InlineFile>. That includes the warning scenario for legacy discount codes as well as the error scenario when fetching the discount fails.

Good luck!
